package main

import (
	"bufio"
	"context"
	"encoding/base64"
	"flag"
	"fmt"
	"log"
	"math/big"
	"net/http"
	"os"
	"path"
	"regexp"
	"strings"
	"time"

	ct "github.com/google/certificate-transparency-go"
	"github.com/google/certificate-transparency-go/client"
	"github.com/google/certificate-transparency-go/jsonclient"
	"github.com/google/certificate-transparency-go/scanner"
	"github.com/google/certificate-transparency-go/x509"
)

const (
	// matchesNothingRegex is a regex which cannot match any input.
	matchesNothingRegex = "a^"
	outputDir           = "./output"
)

var (
	//logURI = flag.String("log_uri", "https://ct.googleapis.com/aviator", "CT log base URI")

	matchSubjectRegex = flag.String("match_subject_regex", ".*", "Regex to match CN/SAN")
	matchIssuerRegex  = flag.String("match_issuer_regex", "", "Regex to match in issuer CN")
	precertsOnly      = flag.Bool("precerts_only", false, "Only match precerts")
	serialNumber      = flag.String("serial_number", "", "Serial number of certificate of interest")
	sctTimestamp      = flag.Uint64("sct_timestamp_ms", 0, "Timestamp of logged SCT")

	parseErrors    = flag.Bool("parse_errors", false, "Only match certificates with parse errors")
	nfParseErrors  = flag.Bool("non_fatal_errors", false, "Treat non-fatal parse errors as also matching (with --parse_errors)")
	validateErrors = flag.Bool("validate_errors", false, "Only match certificates with validation errors")

	batchSize     = flag.Int("batch_size", 1000, "Max number of entries to request at per call to get-entries")
	numWorkers    = flag.Int("num_workers", 2, "Number of concurrent matchers")
	parallelFetch = flag.Int("parallel_fetch", 2, "Number of concurrent GetEntries fetches")
	startIndex    = flag.Int64("start_index", 0, "Log index to start scanning at")
	endIndex      = flag.Int64("end_index", 0, "Log index to end scanning at (non-inclusive, 0 = end of log)")

	printChains = flag.Bool("print_chains", false, "If true prints the whole chain rather than a summary")
	dumpDir     = flag.String("dump_dir", "", "Directory to store matched certificates in")

	hostnameSeenTimes = make(map[string]time.Time)
)

func dumpData(entry *ct.RawLogEntry) {
	if *dumpDir == "" {
		return
	}
	prefix := "unknown"
	suffix := "unknown"
	switch eType := entry.Leaf.TimestampedEntry.EntryType; eType {
	case ct.X509LogEntryType:
		prefix = "cert"
		suffix = "leaf"
	case ct.PrecertLogEntryType:
		prefix = "precert"
		suffix = "precert"
	default:
		log.Printf("Unknown log entry type %d", eType)
	}

	if len(entry.Cert.Data) > 0 {
		name := fmt.Sprintf("%s-%014d-%s.der", prefix, entry.Index, suffix)
		filename := path.Join(*dumpDir, name)
		if err := os.WriteFile(filename, entry.Cert.Data, 0644); err != nil {
			log.Printf("Failed to dump data for %s at index %d: %v", prefix, entry.Index, err)
		}
	}

	for ii := 0; ii < len(entry.Chain); ii++ {
		name := fmt.Sprintf("%s-%014d-%02d.der", prefix, entry.Index, ii)
		filename := path.Join(*dumpDir, name)
		if err := os.WriteFile(filename, entry.Chain[ii].Data, 0644); err != nil {
			log.Printf("Failed to dump data for CA at index %d: %v", entry.Index, err)
		}
	}
}

func logCertInfo(entry *ct.RawLogEntry) {
	parsedEntry, err := entry.ToLogEntry()
	if x509.IsFatal(err) || parsedEntry.X509Cert == nil {
		log.Printf("Process cert at index %d: <unparsed: %v>", entry.Index, err)
		return
	}

	cn := parsedEntry.X509Cert.Subject.CommonName
	updateSeenTimes(cn)

	log.Printf("Process cert at index %d:", entry.Index)
	log.Printf("  CN: '%s'", cn)
	log.Printf("  Issuer: '%s'", parsedEntry.X509Cert.Issuer.CommonName)

	validFrom := parsedEntry.X509Cert.NotBefore.Format("2006-01-02 15:04:05")
	validTo := parsedEntry.X509Cert.NotAfter.Format("2006-01-02 15:04:05")

	log.Printf("  Valid From: %s", validFrom)
	log.Printf("  Valid To: %s", validTo)

	log.Printf("  X.509 Alternative Names:")
	for _, name := range parsedEntry.X509Cert.DNSNames {
		log.Printf("    %s", name)
	}

	output := fmt.Sprintf("%d | cert | %s | %s | %s | %s | %s | %s\n",
		entry.Index,
		cn,
		strings.Join(parsedEntry.X509Cert.DNSNames, ", "),
		validFrom,
		validTo,
		hostnameSeenTimes[cn].Format("2006-01-02 15:04:05"),
		time.Now().Format("2006-01-02 15:04:05"))

	// Save the output to a file or append to an existing file
	saveOutputToFile(cn, "cert", output)
	dumpData(entry)
}

func logPrecertInfo(entry *ct.RawLogEntry) {
	parsedEntry, err := entry.ToLogEntry()
	if x509.IsFatal(err) || parsedEntry.Precert == nil {
		log.Printf("Process precert at index %d: <unparsed: %v>", entry.Index, err)
		return
	}

	cn := parsedEntry.Precert.TBSCertificate.Subject.CommonName
	updateSeenTimes(cn)

	log.Printf("Process precert at index %d:", entry.Index)
	log.Printf("  CN: '%s'", cn)
	log.Printf("  Issuer: '%s'", parsedEntry.Precert.TBSCertificate.Issuer.CommonName)

	validFrom := parsedEntry.Precert.TBSCertificate.NotBefore.Format("2006-01-02 15:04:05")
	validTo := parsedEntry.Precert.TBSCertificate.NotAfter.Format("2006-01-02 15:04:05")

	log.Printf("  Valid From: %s", validFrom)
	log.Printf("  Valid To: %s", validTo)

	log.Printf("  X.509 Alternative Names:")
	for _, name := range parsedEntry.Precert.TBSCertificate.DNSNames {
		log.Printf("    %s", name)
	}

	output := fmt.Sprintf("%d | precert | %s | %s | %s | %s | %s | %s\n",
		entry.Index,
		cn,
		strings.Join(parsedEntry.Precert.TBSCertificate.DNSNames, ", "),
		validFrom,
		validTo,
		hostnameSeenTimes[cn].Format("2006-01-02 15:04:05"),
		time.Now().Format("2006-01-02 15:04:05"))

	// Save the output to a file or append to an existing file
	saveOutputToFile(cn, "precert", output)
	dumpData(entry)
}

func saveOutputToFile(cn, entryType, output string) {
	// Sanitize CN to create a valid filename
	sanitizedCN := sanitizeFilename(cn)

	// Construct the filename based on sanitized CN
	filename := fmt.Sprintf("%s/%s.txt", outputDir, sanitizedCN)

	// Check if the file already exists
	if _, err := os.Stat(filename); os.IsNotExist(err) {
		// File doesn't exist, create a new file and write the header
		createNewFile(filename, output)
	} else {
		// File exists, open it for append
		appendToFile(filename, output)
	}
}

func sanitizeFilename(filename string) string {
	// Replace invalid characters with underscores
	invalidChars := regexp.MustCompile(`[^\w\-.]`)
	sanitized := invalidChars.ReplaceAllString(filename, "_")
	return sanitized
}

func createNewFile(filename, output string) {
	// Create the output directory if it doesn't exist
	if err := os.MkdirAll(outputDir, os.ModePerm); err != nil {
		log.Printf("Failed to create output directory: %v", err)
		return
	}

	// Open the file for writing (or create it if it doesn't exist)
	file, err := os.Create(filename)
	if err != nil {
		log.Printf("Failed to create file %s: %v", filename, err)
		return
	}
	defer file.Close()

	// Write the header line as the first line of the file
	header := "Index | cert/precert | commonName | X.509 Alternative Names | Valid From | Valid To | First Seen | Last Seen\n"
	if _, err := file.WriteString(header); err != nil {
		log.Printf("Failed to write header to file %s: %v", filename, err)
		return
	}

	// Write the detailed output
	if _, err := file.WriteString(output); err != nil {
		log.Printf("Failed to save output to file %s: %v", filename, err)
	}
}

func appendToFile(filename, output string) {
	// Open the file for append
	file, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, os.ModeAppend)
	if err != nil {
		log.Printf("Failed to open file %s for append: %v", filename, err)
		return
	}
	defer file.Close()

	// Append the new output to the file
	if _, err := file.WriteString(output); err != nil {
		log.Printf("Failed to append output to file %s: %v", filename, err)
	}
}

func updateSeenTimes(cn string) {
	// Get the current time
	now := time.Now()

	// Check if the CN is present in the dictionary
	if seenTime, exists := hostnameSeenTimes[cn]; exists {
		// Update first_seen to the previously recorded first-seen timestamp
		// while keeping last_seen as the current timestamp
		hostnameSeenTimes[cn] = seenTime
	} else {
		// If the hostname is not in the dictionary, add an entry with
		// the current time as both first_seen and last_seen timestamps
		hostnameSeenTimes[cn] = now
	}

	// Log the first_seen and last_seen timestamps for the CN
	log.Printf("  First Seen: %s", hostnameSeenTimes[cn].Format("2006-01-02 15:04:05"))
	log.Printf("  Last Seen: %s", now.Format("2006-01-02 15:04:05"))
}

func readLinesFromFile(filename string) ([]string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}
	return lines, nil
}

func chainToString(certs []ct.ASN1Cert) string {
	var output []byte

	for _, cert := range certs {
		output = append(output, cert.Data...)
	}

	return base64.StdEncoding.EncodeToString(output)
}

func logFullChain(entry *ct.RawLogEntry) {
	log.Printf("Index %d: Chain: %s", entry.Index, chainToString(entry.Chain))
}

func createRegexes(regexValue string) (*regexp.Regexp, *regexp.Regexp) {
	// Make a regex matcher
	var certRegex *regexp.Regexp
	precertRegex := regexp.MustCompile(regexValue)
	switch *precertsOnly {
	case true:
		certRegex = regexp.MustCompile(matchesNothingRegex)
	case false:
		certRegex = precertRegex
	}

	return certRegex, precertRegex
}

func createMatcherFromFlags(logClient *client.LogClient) (interface{}, error) {
	if *parseErrors {
		return scanner.CertParseFailMatcher{MatchNonFatalErrs: *nfParseErrors}, nil
	}
	if *validateErrors {
		matcher := scanner.CertVerifyFailMatcher{}
		matcher.PopulateRoots(context.TODO(), logClient)
		return matcher, nil
	}
	if *matchIssuerRegex != "" {
		certRegex, precertRegex := createRegexes(*matchIssuerRegex)
		return scanner.MatchIssuerRegex{
			CertificateIssuerRegex:    certRegex,
			PrecertificateIssuerRegex: precertRegex}, nil
	}
	if *serialNumber != "" {
		log.Printf("Using SerialNumber matcher on %s", *serialNumber)
		var sn big.Int
		_, success := sn.SetString(*serialNumber, 0)
		if !success {
			return nil, fmt.Errorf("invalid serialNumber %s", *serialNumber)
		}
		return scanner.MatchSerialNumber{SerialNumber: sn}, nil
	}
	if *sctTimestamp != 0 {
		log.Printf("Using SCT Timestamp matcher on %d (%v)", *sctTimestamp, time.Unix(0, int64(*sctTimestamp*1000000)))
		return scanner.MatchSCTTimestamp{Timestamp: *sctTimestamp}, nil
	}
	certRegex, precertRegex := createRegexes(*matchSubjectRegex)
	return scanner.MatchSubjectRegex{
		CertificateSubjectRegex:    certRegex,
		PrecertificateSubjectRegex: precertRegex}, nil
}

func main() {
	logURILines, err := readLinesFromFile("all_log_urls.txt")
	if err != nil {
		log.Fatalf("Failed to read log_uri from file: %v", err)
	}

	for _, logURIFromFile := range logURILines {
		logClient, err := client.New(logURIFromFile, &http.Client{
			Timeout: 10 * time.Second,
			Transport: &http.Transport{
				TLSHandshakeTimeout:   60 * time.Second,
				ResponseHeaderTimeout: 30 * time.Second,
				MaxIdleConnsPerHost:   10,
				DisableKeepAlives:     false,
				MaxIdleConns:          100,
				IdleConnTimeout:       90 * time.Second,
				ExpectContinueTimeout: 1 * time.Second,
			},
		}, jsonclient.Options{UserAgent: "ct-go-scanlog/1.0"})
		if err != nil {
			log.Fatal(err)
		}
		matcher, err := createMatcherFromFlags(logClient)
		if err != nil {
			log.Fatal(err)
		}

		opts := scanner.ScannerOptions{
			FetcherOptions: scanner.FetcherOptions{
				BatchSize:     *batchSize,
				ParallelFetch: *parallelFetch,
				StartIndex:    *startIndex,
				EndIndex:      *endIndex,
			},
			Matcher:    matcher,
			NumWorkers: *numWorkers,
		}
		s := scanner.NewScanner(logClient, opts)

		ctx := context.Background()
		if *printChains {
			if err := s.Scan(ctx, logFullChain, logFullChain); err != nil {
				log.Fatal(err)
			}
		} else {
			if err := s.Scan(ctx, logCertInfo, logPrecertInfo); err != nil {
				log.Fatal(err)
			}
		}
	}
}
